# -*- coding: utf-8 -*-
"""Ising model project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zj9IeGdOVjzlH3jnbCBN79lLnktkJVci

###Physics 3020 Ising Model
###Hailey Aronson and Finn Bergquist

In this project you will simulate the magnetic properties of a two-dimensional ferromagnetic material with
the help of the Ising model.

Goal is to find the **magnetization** and **energy** per spin as a function of temperature. Details in assignment sheet.
"""

#Importing useful things
import numpy as np
import scipy as sp
import random
import matplotlib.pyplot as plt

#Test to make sure mod command works for finding neighboors along the boundaries
test_m = 4
test_array = [[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15]]
print(test_array)

#We want to test (x-1),(x+1), (y-1), (y+1)
print(test_array[(0)%test_m][(3+1)%test_m]) #Testing neigbor of top right corner, want to get 0
print(test_array[(3+1)%test_m][3%test_m]) #Testing bottom of bottom corner, want to get 3
print(test_array[(2)][(0-1)%test_m]) #should get 11
print(test_array[(0-1)%test_m][1]) #should get 13

class world:
  
  #initialize
  def __init__(self, m, T):
    self.k_b = 1
    self.T = T
    self.B = 1/(self.k_b * self.T)
    self.m = m
    self.N = m**2   

    #Set up m x m array of spins
    self.spins = [[1]*m for i in range(m)]

    #Energy value updated in randomSweep(), so that calcEnergy not needed every time
    self.Energy = self.calcEnergy()
 
 

  def changeInEnergy1(self, i, j):
    """Hypothetically, what would change in energy be if spin flipped
    at specific coordinates"""
    currentSpin = -1 * self.spins[i][j] #hypothetically changing spin, not actually modifying spin array yet

    #relevant spin energies with old sign (3 terms)
    energy_0 = -self.spins[i][j] * (self.spins[(i+1)%self.m][j%self.m] + self.spins[(i-1)%self.m][j%self.m]
                                    + self.spins[i%self.m][(j-1)%self.m] + self.spins[i%self.m][(j+1)%self.m])                                

    dE = 2*energy_0
    return -1*dE
  
  
  def randomSweep(self):
    """
    choose a random coordinate and calculate its dE if flipped using changeInEnergy()
    will be called N times in nSweeps

    """
    #choose a random int coordinates between 0 and m
    randomX = random.randrange(0,self.m,1)
    randomY = random.randrange(0,self.m,1)

    #condition for if spin changesL:
    dE = self.changeInEnergy1(randomX, randomY)
    randNum = random.random()
    if randNum < np.exp(-1*(self.B)*dE):
      self.spins[randomX][randomY] *= -1 #flip
      self.Energy += dE #keep eye on this negative

  def nSweeps(self):
    """Calls for N random sweeps"""
    for i in range(0, self.N):
      self.randomSweep()
    
  def calcEnergy(self):
    """Returns energy of current state / number of spins"""
    energy = 0
    for i in range(0,self.m):
      for j in range(0,self.m):
        energy += self.spins[i][j]*(self.spins[(i+1)%self.m][j]+self.spins[i][(j+1)%self.m])

    return -1*(energy/self.N)

  def calculateMagnetization(self):
    """sum of all spins / number of spins"""
    magnetization = 0
    for i in range(0, self.m):
      for j in range(0, self.m):
        magnetization += self.spins[i][j]

    return magnetization/self.N

#Compared computed values of E, M, and dE with analytical values for two different matrices with m = 3 before creating graphs

"""Creating """

ourWorld = world(64, 2)

N = []
E = []
M = []

for i in range(0,50):
  ourWorld.nSweeps()
  N.append(i)
  E.append(ourWorld.calcEnergy())
  M.append(ourWorld.calculateMagnetization())

plt.plot(N,E,'g',label = 'Energy')
plt.title('Energy per Spin versus Number of Sweeps')
plt.xlabel('Number of sweeps')
plt.ylabel('E/J')
plt.legend()

#Magnitization plot
plt.plot(N,M,'m',label = "Magnitization")
plt.title('Magnetization per Spin versus Number of Sweeps')
plt.xlabel('Number of sweeps')
plt.ylabel('Magnetization Per Spin')

'''Here's where we ran some tests for a smaller matrix'''

testWorld = world(4, 5)

newWorld = world(64, 2)
nVals=[]
eVals=[]
mVals=[]
for i in range(0,50):
  ourWorld.nSweeps()
  if i > 30:
    nVals.append(i)
    eVals.append(ourWorld.calcEnergy())
    mVals.append(ourWorld.calculateMagnetization())

eAvg = sum(eVals)/len(eVals)
eStdDev = np.std(eVals)
mAvg = sum(mVals)/len(mVals)
mStdDev = np.std(mVals)
print("Spin System with m=64 and T=2 in equilibrium region(between 20th and 50th sweeps)\n")
print("Average Energy/J per spin:", eAvg)
print("Energy standard deviation:", eStdDev)
print("Average Magnetization per spin:", mAvg)
print("Magnetization standard deviation", mStdDev)

def calcAverages(T):
  """Helper function that calculates averages for magnetization and energy at given temperature
  These averages only include terms between the 20 and 50th sweeps, because that is the equlibirum region.
  the values are much more consistent in equilibrium compared to the transient region """
  eVals1 = []
  mVals1 = []
  newWorld = world(64, T)
  for i in range(0, 20):#don't store data
    newWorld.nSweeps()

  for j in range(20, 50):#store data
    newWorld.nSweeps()
    eVals1.append(newWorld.calcEnergy())
    mVals1.append(newWorld.calculateMagnetization())

  eAvg = (sum(eVals1))/(len(eVals1))
  mAvg = (sum(mVals1))/(len(mVals1))
  return eAvg, mAvg#return averages per spin


eAvgVals = []
mAvgVals = []
tVals = []
for i in range(2,10):
  avgE, avgM = calcAverages(i)
  tVals.append(i)
  eAvgVals.append(avgE)
  mAvgVals.append(avgM)



plt.plot(tVals,eAvgVals,'c',label = 'Energy')
plt.title('Average Energy/J per spin versus Termperature')
plt.xlabel('Temperature (K)')
plt.ylabel('Average Energy/J per spin')

plt.plot(tVals,mAvgVals,'c',label = 'Energy')
plt.title('Average Magnetization per spin versus Termperature')
plt.xlabel('Temperature (K)')
plt.ylabel('Average Magnetization per spin')